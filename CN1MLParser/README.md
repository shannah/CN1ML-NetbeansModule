#CN1ML Parser

##Synopsis

This library converts HTML-ish files into Codename One UI Java classes.  It allows you to design templates for your Codename One UI components using a variant of HTML, and use them inside your Codename One applications.

Conversion is done at compile time, so that:

1. You don't incur any performance penalty for using a template and
2. The build server can still strip dead code from your application at build time (i.e. the all dependencies will be converted to Java code which allows for static code analysis).

##Motivation

Codename One already has a fantastic WYSIWYG GUI builder.  Why is this even necessary?  In fact the resource files edited and generated by the GUI builder can be exported to XML.  So why bother with this templating library?

I created this library because sometimes I want to express my UI structure using code or text.  The XML produced by the resource editor is not meant to be edited by humans.  Using Java directly to describe a component hierarchy quickly turns into a mess that is difficult to maintain.  I wanted a format that was simple to be hand-coded, and provided a simple birds-eye view of the UI component hierarchy.

##License

[Apache 2.0](http://www.apache.org/licenses/LICENSE-2.0.txt)

##Dependencies

1. Jsoup 1.7.3  - for HTML Parsing.
2. Java 7 or higher

##Usage Example

The following example will generate source code for a class named `mypkg.MyClass` based on the template contents in the `html` String variable.

~~~
import ca.weblite.codename1.cn1ml.CN1ML;

...

String javaClassString = new CN1ML("mypkg.MyClass").buildClass(html);
~~~

##Sample Input/Output:

###Template:

~~~
<html>
    <body layout="BorderLayout">
        <div layout-constraint="NORTH" name="StatusBar" uiid="TopBar">
            Welcome to my App
        </div>
        <div layout-constraint="CENTER" name="MainPanel" uiid="MainArea">
            
        </div>
    </body>
</html>
~~~

###Output:

~~~
package com.mycompany.myapp;
/* THIS FILE IS AUTOMATICALLY GENERATED-- DO NOT MODIFY IT*/

import com.codename1.ui.*;
import com.codename1.ui.layouts.*;
import com.codename1.ui.table.*;

class Form2 {

    private Container rootContainer;

    public Container getRoot() {
        if (rootContainer == null) {
            rootContainer = buildUI();
        }
        return rootContainer;
    }
    private java.util.Map<String, Component> _nameIndex = new java.util.HashMap<String, Component>();

    public Component get(String name) {
        getRoot();
        return _nameIndex.get(name);
    }

    public Form2(java.util.Map context) {
    }

    private Container buildUI() {
        Container root = new Container();
        BorderLayout rootLayout = new BorderLayout();
        root.setLayout(rootLayout);
        Container node1 = new Container();
        FlowLayout node1Layout = new FlowLayout();
        node1.setLayout(node1Layout);
        node1.setUIID("TopBar");
        node1.setName("StatusBar");
        _nameIndex.put("StatusBar", node1);
        root.addComponent(BorderLayout.NORTH, node1);
        node1.addComponent(new Label(" Welcome to my App "));
        Container node2 = new Container();
        FlowLayout node2Layout = new FlowLayout();
        node2.setLayout(node2Layout);
        node2.setUIID("MainArea");
        node2.setName("MainPanel");
        _nameIndex.put("MainPanel", node2);
        root.addComponent(BorderLayout.CENTER, node2);
        return root;
    }

    public Container getStatusBar() {
        return (Container) get("StatusBar");
    }

    public Container getMainPanel() {
        return (Container) get("MainPanel");
    }
}

~~~

And a simple example of how to use this class:

~~~
Form2 form = new Form2(new java.util.HashMap());
Form myForm = new Form("Hello World");
myForm.setLayout(new BorderLayout());
myForm.addComponent(BorderLayout.CENTER, form.getRoot());
myForm.show();
~~~

which will result in something like this:

![Hello World](screenshots/hello.png)

## A More Complex Example

###Template:

~~~
<!DOCTYPE cn1ml>
<html>
  <head>
    <script type="text/java">
      import ca.weblite.scriblets.models.Board;
      import ca.weblite.scriblets.models.Game;
    </script>
  </head>
  <body layout="BorderLayout" attributes="Board board; Game game;">
    <div name="statusBar" layout="BorderLayout" layout-constraint="NORTH">
      <div name="scoreBoard" layout="X_AXIS" layout-constraint="EAST">
        <div name="playerScoreContainer" uiid="PlayerScoreContainer">
          <label name="playerScoreLabel">You &amp; Me</label>
          <label name="playerScoreValue" data-class="scoreValue">-</label>
        </div>
        <div name="rivalScoreContainer" uiid="PlayerScoreContainer">
          <label name="rivalScoreLabel">Opponent</label>
          <label name="rivalScoreValue" data-class="scoreValue">-</label>
        </div>


      </div>
    </div>
    
    <div name="gameFormLayeredLayout" layout="LayeredLayout" layout-constraint="CENTER">
      <script type="text/java">
        self.setScrollable(false);
      </script>
      <div name="gameFormBorderLayout" layout="BorderLayout">
        <div name="rivalContainer" 
             layout-constraint="NORTH" 
             data-player="java:game.getPlayer(1)">
               
        </div>
        <div name="boardContainer" 
             layout-constraint="CENTER" 
             layout="LayeredLayout">
          <table name="boardBackground" 
                 rows="board.getHeight()" 
                 cols="board.getWidth()">
            
          </table>
          <table name="boardCardsContainer" 
                 rows="board.getHeight()" 
                 cols="board.getWidth()">
            
          </table>
        </div>
        <div name="playerContainer" 
             layout-constraint="SOUTH" 
             data-player="java:game.getPlayer(0)">
               
        </div>
        <div name="deckContainer" layout-constraint="EAST"></div>
      </div>
      <div name="gameFormUpperLayer"></div>
    </div>
    
    
  </body>
</html>

~~~

###Resulting .java Class

~~~
package com.mycompany.myapp;

import ca.weblite.scriblets.models.Board;
import ca.weblite.scriblets.models.Game;/* THIS FILE IS AUTOMATICALLY GENERATED-- DO NOT MODIFY IT*/

import com.codename1.ui.*;
import com.codename1.ui.layouts.*;
import com.codename1.ui.table.*;

class MyForm {

    private Container rootContainer;

    public Container getRoot() {
        if (rootContainer == null) {
            rootContainer = buildUI();
        }
        return rootContainer;
    }
    private java.util.Map<String, Component> _nameIndex = new java.util.HashMap<String, Component>();

    public Component get(String name) {
        getRoot();
        return _nameIndex.get(name);
    }
    private Board board;
    private Game game;

    public MyForm(java.util.Map context) {
        board = (Board) context.get("board");
        game = (Game) context.get("game");
    }

    private Container buildUI() {
        Container root = new Container();
        BorderLayout rootLayout = new BorderLayout();
        root.setLayout(rootLayout);
        Container node1 = new Container();
        BorderLayout node1Layout = new BorderLayout();
        node1.setLayout(node1Layout);
        node1.setName("statusBar");
        _nameIndex.put("statusBar", node1);
        root.addComponent(BorderLayout.NORTH, node1);
        Container node2 = new Container();
        BoxLayout node2Layout = new BoxLayout(BoxLayout.X_AXIS);
        node2.setLayout(node2Layout);
        node2.setName("scoreBoard");
        _nameIndex.put("scoreBoard", node2);
        node1.addComponent(BorderLayout.EAST, node2);
        Container node3 = new Container();
        FlowLayout node3Layout = new FlowLayout();
        node3.setLayout(node3Layout);
        node3.setUIID("PlayerScoreContainer");
        node3.setName("playerScoreContainer");
        _nameIndex.put("playerScoreContainer", node3);
        node2.addComponent(node3);
        Label node4 = new Label();
        node4.setName("playerScoreLabel");
        _nameIndex.put("playerScoreLabel", node4);
        node3.addComponent(node4);
        node4.setText("You & Me");
        Label node5 = new Label();
        node5.putClientProperty("class", "scoreValue");
        node5.setName("playerScoreValue");
        _nameIndex.put("playerScoreValue", node5);
        node3.addComponent(node5);
        node5.setText("-");
        Container node6 = new Container();
        FlowLayout node6Layout = new FlowLayout();
        node6.setLayout(node6Layout);
        node6.setUIID("PlayerScoreContainer");
        node6.setName("rivalScoreContainer");
        _nameIndex.put("rivalScoreContainer", node6);
        node2.addComponent(node6);
        Label node7 = new Label();
        node7.setName("rivalScoreLabel");
        _nameIndex.put("rivalScoreLabel", node7);
        node6.addComponent(node7);
        node7.setText("Opponent");
        Label node8 = new Label();
        node8.putClientProperty("class", "scoreValue");
        node8.setName("rivalScoreValue");
        _nameIndex.put("rivalScoreValue", node8);
        node6.addComponent(node8);
        node8.setText("-");
        Container node9 = new Container();
        LayeredLayout node9Layout = new LayeredLayout();
        node9.setLayout(node9Layout);
        node9.setName("gameFormLayeredLayout");
        _nameIndex.put("gameFormLayeredLayout", node9);
        root.addComponent(BorderLayout.CENTER, node9);
        init_node9(node9);
        Container node10 = new Container();
        BorderLayout node10Layout = new BorderLayout();
        node10.setLayout(node10Layout);
        node10.setName("gameFormBorderLayout");
        _nameIndex.put("gameFormBorderLayout", node10);
        node9.addComponent(node10);
        Container node11 = new Container();
        FlowLayout node11Layout = new FlowLayout();
        node11.setLayout(node11Layout);
        node11.putClientProperty("player", game.getPlayer(1));
        node11.setName("rivalContainer");
        _nameIndex.put("rivalContainer", node11);
        node10.addComponent(BorderLayout.NORTH, node11);
        Container node12 = new Container();
        LayeredLayout node12Layout = new LayeredLayout();
        node12.setLayout(node12Layout);
        node12.setName("boardContainer");
        _nameIndex.put("boardContainer", node12);
        node10.addComponent(BorderLayout.CENTER, node12);
        Container node13 = new Container();
        TableLayout node13Layout = new TableLayout(board.getHeight(), board.getWidth());
        node13.setLayout(node13Layout);
        node13.setName("boardBackground");
        _nameIndex.put("boardBackground", node13);
        node12.addComponent(node13);
        Container node14 = new Container();
        TableLayout node14Layout = new TableLayout(board.getHeight(), board.getWidth());
        node14.setLayout(node14Layout);
        node14.setName("boardCardsContainer");
        _nameIndex.put("boardCardsContainer", node14);
        node12.addComponent(node14);
        Container node15 = new Container();
        FlowLayout node15Layout = new FlowLayout();
        node15.setLayout(node15Layout);
        node15.putClientProperty("player", game.getPlayer(0));
        node15.setName("playerContainer");
        _nameIndex.put("playerContainer", node15);
        node10.addComponent(BorderLayout.SOUTH, node15);
        Container node16 = new Container();
        FlowLayout node16Layout = new FlowLayout();
        node16.setLayout(node16Layout);
        node16.setName("deckContainer");
        _nameIndex.put("deckContainer", node16);
        node10.addComponent(BorderLayout.EAST, node16);
        Container node17 = new Container();
        FlowLayout node17Layout = new FlowLayout();
        node17.setLayout(node17Layout);
        node17.setName("gameFormUpperLayer");
        _nameIndex.put("gameFormUpperLayer", node17);
        node9.addComponent(node17);
        return root;
    }

    public Container getStatusBar() {
        return (Container) get("statusBar");
    }

    public Container getScoreBoard() {
        return (Container) get("scoreBoard");
    }

    public Container getPlayerScoreContainer() {
        return (Container) get("playerScoreContainer");
    }

    public Label getPlayerScoreLabel() {
        return (Label) get("playerScoreLabel");
    }

    public Label getPlayerScoreValue() {
        return (Label) get("playerScoreValue");
    }

    public Container getRivalScoreContainer() {
        return (Container) get("rivalScoreContainer");
    }

    public Label getRivalScoreLabel() {
        return (Label) get("rivalScoreLabel");
    }

    public Label getRivalScoreValue() {
        return (Label) get("rivalScoreValue");
    }

    public Container getGameFormLayeredLayout() {
        return (Container) get("gameFormLayeredLayout");
    }

    private void init_node9(Container self) {
        self.setScrollable(false);
    }

    public Container getGameFormBorderLayout() {
        return (Container) get("gameFormBorderLayout");
    }

    public Container getRivalContainer() {
        return (Container) get("rivalContainer");
    }

    public Container getBoardContainer() {
        return (Container) get("boardContainer");
    }

    public Container getBoardBackground() {
        return (Container) get("boardBackground");
    }

    public Container getBoardCardsContainer() {
        return (Container) get("boardCardsContainer");
    }

    public Container getPlayerContainer() {
        return (Container) get("playerContainer");
    }

    public Container getDeckContainer() {
        return (Container) get("deckContainer");
    }

    public Container getGameFormUpperLayer() {
        return (Container) get("gameFormUpperLayer");
    }
}

~~~

##Some Comments on Code Generation

As you can see from the examples, the `<body>` tag is generated as the "Root Node", which is always an instance of `com.codename1.ui.Container`, unless you provide a `class` attribute to specify a different class.  The DOM hierarchy inside the `<body>` are converted to a corresponding Component hierarchy in the Codename One java class.

###Component Types

The default class that most tags will be converted to is `Container`, with the following exceptions:

1. `<label>` is converted to a `Label`
2. `<button>` is converted to a `Button`

In the future I'll be adding more specialized tag support (e.g. I'd like `<input type="text"/>` to be converted to `TextField` and `<textarea>` to be converted to `TextBox` but this isn't done yet).

It is best practice to use `<div>` tags for all `Containers` to avoid being affected by specializations later on with different tags.

###Layouts

The default layout for most containers is `FlowLayout`.  One notable exception is the `<table>` tag which uses `TableLayout` by default. You can specify a different layout using the `layout` attribute.  E.g.

~~~
 <div layout="BorderLayout"></div>
~~~

or

~~~
 <div layout="BoxLayout(BoxLayout.X_AXIS)"></div>
~~~

or

~~~
 <div layout="com.codename1.ui.layouts.BoxLayout(BoxLayout.X_AXIS)"></div>
~~~

or

~~~
 <div layout="GridLayout(1,5)"></div>
~~~

Shortcuts have been created for the following layouts to make for less typing:

* `X_AXIS` -> `BoxLayout(BoxLayout.X_AXIS)`
* `Y_AXIS` -> `BoxLayout(BoxLayout.Y_AXIS)`
* `x` -> `BoxLayout(BoxLayout.X_AXIS)`
* `y` -> `BoxLayout(BoxLayout.Y_AXIS)`

E.g. The Following are all equivalent:

~~~
 <div layout="com.codename1.ui.layouts.BoxLayout(BoxLayout.X_AXIS)"></div>
 <div layout="BoxLayout(BoxLayout.X_AXIS)"></div>
 <div layout="X_AXIS"></div>
 <div layout="x"></div>
~~~


###Layout Constraints

Some layouts require their child components to provide layout constraints.  E.g. If the parent container uses BorderLayout, all children need to specify which area it should be placed into (e.g. NORTH, SOUTH, EAST, WEST, CENTER).  

E.g.

~~~
 <div layout="BorderLayout">
     <div layout-constraint="NORTH">North text</div>
     <div layout-constraint="SOUTH">South text</div>
     <div layout-constraint="BorderLayout.CENTER">
     	Example using full name of constraint
     </div>
     <div layout-constraint="MyOtherClass.createConstraint()">
     	Example using a generator function from another class of mine.
     	** Note:  You may have to import the class in the header**
     </div>
 </div>
~~~

The above example shows a few different flavors of constraints.  There are shortcuts for some of the common constraints (e.g. NORTH, SOUTH, etc..), or you can include the fully qualified constraint name (e.g. BorderLayout.CENTER).  This works because the generated class always includes import statements :

~~~
import com.codename1.ui.*;
import com.codename1.ui.layouts.*;
import com.codename1.ui.table.*;
~~~

If you need to refer to a constraint that isn't included in these default imports, you would either need to include the fully-qualified name, or add your own imports inside a `<script>` tag within the `<head>` of the document.  E.g.

~~~
<html>
  <head>
    <script type="text/java">
      import ca.weblite.scriblets.models.Board;
      import ca.weblite.scriblets.models.Game;
    </script>
  </head>
  ...
~~~

### Names

You should give names to any component that you want to be able to access from code.  All components generated from tags that include the `name` attribute, will have accessor methods generated in the form `getName()`.

E.g.

~~~
 <table name="boardBackground" 
   rows="board.getHeight()" 
   cols="board.getWidth()">
 </table>
~~~

Results in a method `Container getBoardBackground();` being generated as part of the class, so that you can access this container easily.

### UIIDs

Use the `uiid` attribute to assign a UIID to the resulting component.

e.g.

~~~
 <div uiid="MyCustomStyle"></div>
~~~

will result in this compontn being assigned the "MyCustomStyle" UIID.

### Client Properties

You can assign client properties to components using `data-xyz` attributes.  E.g. This:

~~~
 <label name="rivalScoreValue" data-class="scoreValue">-</label>
~~~

Will generate a `Label` and the call `putClientProperty("class", "scoreValue"))` on the label.  This allows you to attach arbitrary data to your components.

The value you assign to your client properties are assumed to be `String`s, unless you prefix it with `java:`.  Then it is assumed to be a Java expression (which can be an int, double, variable, etc..).

E.g. In this example:

~~~
 <div name="rivalContainer" 
   layout-constraint="NORTH" 
   data-player="java:game.getPlayer(1)">
 </div>
~~~

We have assigned the result of `game.getPlayer(1)` to the `player` property of the component.

**`game` was provided as an attribute of the template at via the `attributes` attribute of the `body` tag.**  

### Script Tags (Custom Initialization Code)

You can also embed `<script>` tags containing custom Java code to be executed during initialization.  The code inside the `<script>` tag will be executed during at the time the component of the parent tag is instantiated.

E.g.

~~~
 <div name="gameFormLayeredLayout" layout="LayeredLayout" layout-constraint="CENTER">
      <script type="text/java">
        self.setScrollable(false);
      </script>
    ...
    
~~~

In this example, the Container generated from the `<div>` tag will be set to not scroll because it will have setScrollable(false) called on it.  The "self" key word is akin to `this`.  It refers to the Component that is being initialized.

Code inside the script tags will be run inside the context of the generated class so you can access any of the class's functionality using `this` (to refer to the generated class).  You can also access any attributes that have been passed to the template.

###Adding Custom imports

If you add a `script` tag to the `head` of the document, the contents will be rendered between the `package`	statement and the class declaration.  This is an appropriate place to put `import` statements.  E.g.

~~~
<!DOCTYPE cn1ml>
<html>
  <head>
    <script type="text/java">
      import ca.weblite.scriblets.models.Board;
      import ca.weblite.scriblets.models.Game;
    </script>
  </head>

~~~

### Passing Data To the Template

It is possible to pass data to your template via the `attributes` attribute.  Typically you would specify these in the `<body>` tag.  E.g. In the complex example shown previously, the `<body>` tag looked like:

~~~
 <body layout="BorderLayout" attributes="Board board; Game game;">
 ...
 </body>
~~~

This specified that this template takes two parameters: 

* board : An instance of the `Board` class.
* game : An instance of the `Game` class.

These attributes can be used throughout the template anywhere an expression can be placed.

If you add attributes to your template, you must supply them to the class' constructor when you instantiate the class that was generated by your template.  E.g.  In the above example (with a 'board' and 'game' attribute), we would instantiate the class with:

~~~
HashMap props = new HashMap();
props.put('game', new Game());
props.put('board', new Board());

MyForm myForm = new MyForm(props);
~~~
 
### Text

If you add text content to your template, it will be included in the Component hierarchy as follows:

1. As the text of a parent Label or Button, if it is directly inside a `<label>` or `<button>` tag.
2. As an anonymous Label if it is inside any other tag.


##Special Component Types

### Tables

`<table>` tags are converted to Containers with the `TableLayout` layout.  You can specify the number of rows and columns of the layout using the `rows` and `cols` attributes of the `<table>` tag, e.g.

~~~
 <table rows="5" cols="6"></table>
~~~

You can also provide expressions for rows and rols:
e.g.

~~~
 <table name="boardBackground" 
   rows="board.getHeight()" 
   cols="board.getWidth()">
 </table>
~~~




